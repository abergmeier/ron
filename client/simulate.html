<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>RON</title>
		<script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script>
		<script type="text/javascript" src="mimic.js"></script>
		<script type="text/javascript">

			//* Start of simulation block
			//set the type of page			
			var _simulation = new Simulation();

			function Simulation()
			{
				var player1Positions = new Object();
				player1Positions[0 * 1000] = new google.maps.LatLng(53.089062, 8.785372);
				player1Positions[3 * 1000] = new google.maps.LatLng(53.090448, 8.789685);
				player1Positions[7 * 1000] = new google.maps.LatLng(53.088898, 8.790016);
				player1Positions[14 * 1000] = new google.maps.LatLng(53.088499, 8.792035);
				player1Positions[15 * 1000] = new google.maps.LatLng(53.089146, 8.792739);
				player1Positions[19 * 1000] = new google.maps.LatLng(53.090638, 8.791516);
				
				var player2Positions = new Object();				
				var player3Positions = new Object();
				var player4Positions = new Object();

				this._playerPositions = new Array
				(
					player1Positions,
					player2Positions,
					player3Positions,
					player4Positions
				);

				var player1Nodes = new Object();
				player1Nodes[2 * 1000] = true;
				player1Nodes[6 * 1000] = true;
				player1Nodes[10 * 1000] = true;

				var player2Nodes = new Object();
				var player3Nodes = new Object();
				var player4Nodes = new Object();

				this._playerNodes = new Array
				(
					player1Nodes,
					player2Nodes,
					player3Nodes,
					player4Nodes
				);
			};

			Simulation.prototype.onClick = function()
			{
				var nodes = this._playerNodes[getPlayer().getId() - 1];
				var node;

				for(var seconds in nodes)
				{
					self.setTimeout
					(
						function()
						{
							submitPoint();
						},
						parseInt(seconds)		
					);					
				} 
			};

			Simulation.prototype.watchPosition = function(functionName)
			{
				var len = this._playerPositions;
				var positions = this._playerPositions[getPlayer().getId() - 1];
				
				var position;
				var wrapper;
				
				for(var seconds in positions)
				{
					position = positions[seconds];
					wrapper = new Object();
					wrapper.coords = new Object();
					wrapper.coords.latitude = position.lat();
					wrapper.coords.longitude = position.lng();
					
					self.setTimeout
					(
						function()
						{					
							functionName(wrapper);
						},
						parseInt(seconds)
					);
				}
					
				return null;
			};

			//* End of simulation block

			//use object for associative array - works better
			var _players = new Object();
			_players.length = 0;
			var colors = new Array("#000000", "#0000FF", "#FF0000", "#FFFF00", "00FF00");

			var _playerId;

			var _map;

			function Line(player)
			{
				this.Player = player;
				this.Partials = new Array();
				this.PolyLine = null;
			};

			Line.prototype.removePartials = function()
			{
				if(!this.Partials)
					return; //already removed
					
				//remove all polylines
				var last;
				while(last = this.Partials.pop())
				{
					last.setMap(null);
				}

				//we no longer need the array
				this.Partials = null;
			};

			Line.prototype.set = function(startLat, startLng, endLat, endLng)
			{
				var start = new google.maps.LatLng(startLat, startLng);
				var end = new google.maps.LatLng(endLat, endLng);
			
				this.PolyLine = new google.maps.Polyline
				(
					{
			       		path:[start, end],
			       		strokeColor: this.Player.Color,
			       		strokeOpacity: 1.0,
			       		strokeWeight: 3
					}
				);
				this.PolyLine.setMap(_map);

				this.removePartials();

				//make sure line is displayed
				fitBounds(start);
				fitBounds(end);
			};

			Line.prototype.setPartial = function(startLat, startLng, endLat, endLng)
			{
				if(!isPartial())
					return; //we already have the whole line

				var start = new google.maps.LatLng(startLat, startLng);
				var end = new google.maps.LatLng(endLat, endLng);
					
				var polyLine = new google.maps.Polyline
				(
					{
			       		path:[start, end],
			       		strokeColor: this.Player.Color,
			       		strokeOpacity: 1.0,
			       		strokeWeight: 2
			       	}
				);
				polyline.setMap(_map);
				this.Partials.push(polyline);

				//make sure partials are displayed
				fitBounds(start);
				fitBounds(end);
			};

			Line.prototype.isPartial = function()
			{
				return this.PolyLine == null;
			}

			function Player(player_name, player_id)
			{
				this.Name = player_name;
  				this.ID   = player_id;
				this.Color = colors[_players.length];

				this.Lines = new Object();
			};

			Player.prototype.addPartialLine = function(segmentId, startLat, startLng, endLat, endLng)
			{
				var line = this.getLine(segmentId);
				line.addPartial(startLat, startLng, endLat, endLng);
			};

			Player.prototype.addLine = function(segmentId, startLat, startLng, endLat, endLng)
			{
				var line = this.getLine(segmentId);
				line.set(startLat, startLng, endLat, endLng);					
			};

			Player.prototype.getLine = function(segmentId)
			{
				var line = this.Lines[segmentId];

				//no line yet - create new one
				if(!line)
				{
					line = new Line(this);
					this.Lines[segmentId] = line;
				}

				return line;
			};

			Player.prototype.getId = function()
			{
				return this.ID;
			};

			function getPlayerById(id, name)
			{				
				var player = _players[id];

				if(!player)
				{
					if(name)
						player = new Player(name, id);
					else
						player = new Player("unknown", id);
					
					_players[id] = player;
					_players.length++;
				}

				return player;
			}
		
			//save the last servertime of a received update
			var lastServerTime;
			var lastServerPosition = new Array(0, 0);
			var _marker;
			var _bounds;

			var _watchID;
			
			var geoImpl; //which interface for location retrieval to use
			//var ServerUrl = "http://ron.lcid-fire.org/server.php";
			var serverUrl = "http://localhost:8081/";
		
			function callRPCMethod(methodName)
			{
				var request = new XmlRpcRequest(serverUrl, "Server." + methodName);
				for(var i = 1; i < arguments.length; i++)
				{
					request.addParam(arguments[i]);
				}

				var response = request.send();

				response.parseXML();

				if(response.isFault())
					return null;
				else
					return response.params;
			}
		
			function updatePosition(position)
			{
				var lat;
				var lng;
				
				if(position.coords)
				{
					lat = position.coords.latitude;
					lng = position.coords.longitude;
				}
				else
				{
					lat = position.latitude;
					lng = position.longitude;
				}

				var myLatLng = new google.maps.LatLng(lat, lng);

				if(_marker)
					_marker.setPosition(myLatLng);
 				else
				{
					_marker = new google.maps.Marker
					({
      						position: myLatLng, 
							map: _map, 
							title: getPlayer().Name + "s Position"
					});
				}

				//make sure marker is displayed
				_map.panTo(myLatLng);
			}
		
			function submitPoint()
			{
				if(!_marker)
					return;

				var response = callRPCMethod("addNode", getPlayer().getId());

				if(!response || !response[0])
					return; //TODO: handle properly

				var segmentArray = response[0];

				if(!segmentArray.length)
					return; //no segment yet
				
				getPlayer().addLine(segmentArray[0], segmentArray[1], segmentArray[2], segmentArray[3], segmentArray[4]);
			}
		
			/*function displayPoints(player_id)
			{
				var player = _players[player_id];

				if(!player)
				{
					alert("No player with id" + player_id);
					return;
				}
		
				var path = player.Lines[].getPath();
				
				for(var i = 1; i < arguments.length; i += 2)
				{
					// Because path is an MVCArray, we can simply append a new coordinate
					// and it will automatically appear
					var latLng = new google.maps.LatLng(arguments[i], arguments[i + 1]);
					path.insertAt(path.getLength(), latLng);
					
					//make sure map is centered so point is visible
					fitBounds(latLng);
				}
			}*/
			
			function createXml(markup)
			{
				if(!markup)
					return null;
				
				var doc;

				if(window.DOMParser)
				{
					var parser = new DOMParser();
					doc = parser.parseFromString(markup, "text/xml");
				}
				else
				{
					//IE way
					doc = new ActiveXObject("Microsoft.XMLDOM"); 
					doc.async = "false";
					doc.loadXML(markup);
				}
				
				return doc;
			}
			
			function fitBounds(latLng)
			{
				_bounds.extend(latLng);
				_map.fitBounds(_bounds);
			}

			function callForAll(player, elements, callback)
			{
				var rootElement;
				var rootElementId;
				var start;
				var end;
				
				for(var i = 0; i != collection.length; i++)
				{
					rootElement = elements[i];
					rootElementId = rootElement.getAttribute("id");
	
					start = rootElement.getElementsByTagName("start")[0];
					end = rootElement.getElementsByTagName("end")[0];

					callback
					(
						player,
						rootElementId,
						parseFloat(start.getAttribute("lat")),
						parseFloat(start.getAttribute("lng")),
						parseFloat(end.getAttribute("lat")),
						parseFloat(end.getAttribute("lng"))
					);
				}
			}

			function addLine(player, elementId, startLat, startLng, endLat, endLng)
			{
				player.addLine(segmentId, startLat, startLng, endLat, endLng);
			}

			function addPartialLine(player, elementId, startLat, startLng, endLat, endLng)
			{
				player.addPartialLine(segmentId, startLat, startLng, endLat, endLng);	
			}				
		
			function getPoints()
			{
				if(!_marker)
					return; //we cannot do anything without a position
				
				var position = _marker.getPosition();

				var playerId = getPlayer().getId();

				var responseParameters;
				if(lastServerTime)
					responseParameters = callRPCMethod("updateState", playerId, position.lat(), position.lng(), lastServerTime);
				else
					responseParameters = callRPCMethod("updateState", playerId, position.lat(), position.lng());

				if(!responseParameters || !responseParameters.length)
					return; //TODO: problem handling

				lastServerPosition[0] = position.lat(); 
				lastServerPosition[1] = position.lng();

				var responseDocument = createXml(responseParameters[0]);

				if(!responseDocument)
					return; //TODO: handle problem
				
				var stateElement = responseDocument.getElementsByTagName("state")[0];

				if(!stateElement)
					return; //TODO: handle problem
					
				lastServerTime = parseInt(stateElement.getAttribute("time"));
			
				var playerElements = responseDocument.getElementsByTagName("player");
				var id;
				var player;
							
				//process all received player data
				for(var i = 0; i != playerElements.length; i++)
				{
					id = playerElements[i].getAttribute("id");

					player = getPlayerById(id);

					//process whole segments
					callForAll(player, playerElements[i].getElementsByTagName("segment"), addLine);

					//process partial segments
					callForAll(player, playerElements[i].getElementsByTagName("partial"), addPartialLine);
				}
			}

			function getPlayer()
			{
				if(!_playerId)
					return null;

				return _players[_playerId];
			}
		
			function addPlayer(playerName, lat, lng)
			{
				if(getPlayer())
				{
					alert("Multiple players not supported by one client");
					return false;
				}
					
				var parameter = callRPCMethod("addPlayer", playerName, lat, lng);

				if(!parameter || parameter.length == 0)
					return false;
		
				if(!parameter[0])
					return false; //something unexpected went wrong
				
				var	playerId = parseInt(parameter[0]);

				getPlayerById(playerId, playerName);

				//save id of first player
				if(!_playerId)
					_playerId = playerId;

				return true;
			}
		
			function removePlayer()
			{
				if(!getPlayer())
					return; //we don't have logged in player
				
				callRPCMethod("removePlayer", getPlayer().getId());

				for(var id in _players)
				{
					_players[id] = null;
				}
			}

			function login()
			{
				var location;
				
				if(navigator.geolocation)
				{
					location = navigator.geolocation;
					geoImpl = 0;
				}
				else
				{
					var script = document.createElement("script");
					script.setAttribute("type", "text/javascript");
					script.setAttribute("src", "http://code.google.com/apis/gears/gears_init.js");
					document.getElementsByTagName("head")[0].appendChild(script);
					location = google.gears.factory.create('beta.geolocation');
					geoImpl = 1;
				}
			
				location.getCurrentPosition
				(
					function(position)
					{
						var playerName;
						
						if(_simulation)
							playerName = "Bot";
						else
							playerName = prompt("Please enter your player's name", "");
						
						if(playerName == null)
							return;

						var coords;
						
						if(position.coords)
							coords = position.coords;
						else
							coords = position;

						if(!addPlayer(playerName, coords.latitude, coords.longitude))
						{
							alert("Login failed");
							return;
						}

						//position data was sent when created player
						lastServerPosition[0] = coords.latitude;
						lastServerPosition[1] = coords.longitude;

						var myLatLng = new google.maps.LatLng(coords.latitude, coords.longitude);
					
						var myOptions =
						{
							disableDefaultUI: true,
							disableDoubleClickZoom: true,
							keyboardShortcuts: false,
							scrollwheel: false,
							mapTypeControl: false,
							zoom: 10,
							center: myLatLng,
							mapTypeId: google.maps.MapTypeId.ROADMAP
						};
			
						_map = new google.maps.Map(document.getElementById("map_canvas"), myOptions);

						//make sure current position is displayed
						_bounds = new google.maps.LatLngBounds(myLatLng, myLatLng);
						_map.fitBounds(_bounds);
						
						updatePosition(position);

						//be aware that delegation does not work in java
						//as in other programming languages - therefor
						//we need to call the function on their objects
						//to have the correct context 
						
						if(_simulation)
							_simulation.watchPosition(updatePosition); 
						else
							_watchID = location.watchPosition(updatePosition);
		
						//refresh the points every second
						window.setInterval("getPoints()", 1000);

						//user interaction not allowed for simulation
						if(_simulation)
							_simulation.onClick();
						else
						{
							//not working for some awkward reason
							//google.maps.event.addListener(_map, 'click', submitPoint);
							document.onclick = submitPoint;
						}
					}
				);  
			}
		
			function logout()
			{
				if(_watchID && navigator.geolocation)
					navigator.geolocation.clearWatch(_watchID);

				window.clearInterval("getPoints()");
				removePlayer();
			}
			
		</script>
		<meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
		<style type="text/css">
			html, body, body div { width:100%; height:100%; padding:0px; margin:0px}
		</style>
	</head>
	<body onload="login()" onunload="logout()">
		<div id="map_canvas"/>
	</body>
</html>

